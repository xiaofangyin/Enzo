程序计数器：较小的内存空间，当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响

虚拟机栈：每个线程私有的，线程在运行时，在执行每个方法的时候都会打包成一个栈帧，存储了
        局部变量表，操作数栈，动态链接，方法出口等信息，然后放入栈。每个时刻正在执行的当
        前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。
        栈的大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k

        局部变量表:顾名思义就是局部变量的表，用于存放我们的局部变量的。首先它是一个32位的长度，
                  主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就
                  使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的Object对象，
                  我们只需要存放它的一个引用地址即可。
        操作数据栈：存放我们方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是
                  用来操作的，操作的的元素可以是任意的java数据类型，所以我们知道一个方法刚刚
                  开始的时候，这个方法的操作数栈就是空的，操作数栈运行方法是会一直运行入栈/出栈的操作
        动态连接:Java语言特性多态（需要类加载、运行时才能确定具体的方法），动态特性（Groovy、JS、动态代理）
        返回地址:正常返回（调用程序计数器中的地址作为返回）、异常的话（通过异常处理器表<非栈帧中的>来确定）

本地方法栈：各虚拟机自由实现，

方法区/永久代：用于存储已经被虚拟机加载的类信息，常量("zdy","123"等)，静态变量(static变量)等数据，

堆：几乎所有对象都分配在这里，也是垃圾回收发生的主要区域，



栈上分配/逃逸分析
虚拟机提供的一种优化技术，基本思想是，对于线程私有的对象，将它打散分配在栈上，而不分配在堆上。
好处是对象跟着方法调用自行销毁，不需要进行垃圾回收，可以提高性能。
栈上分配需要的技术基础，逃逸分析。逃逸分析的目的是判断对象的作用域是否会逃逸出方法体。
注意，任何可以在多个线程之间共享的对象，一定都属于逃逸对象。
public void test(int x,inty ){
String x = “”;
User u = ….
…..
}
User类型的对象u就没有逃逸出方法test。
public  User test(int x,inty ){
String x = “”;
User u = ….
…..
return u;
}
User类型的对象u就逃逸出方法test。