快   流畅的体验   卡顿
稳      稳定      内存泄漏/崩溃
省   省电/流量     代码质量和逻辑
小    安装包小     安装包过大

快，稳，省，小，这四点很形象的代表了性能的四个方面，同时也让我们知道我们App现在是否是款性能良好的APP，如果有一项不达标，那么说明我们的应用有待优化。

1、布局优化(HierarchyViewer)
    1).如果父控件有颜色，也是自己需要的颜色，那么就不必在子控件加背景颜色
    2).如果每个自控件的颜色不太一样，而且可以完全覆盖父控件，那么就不需要再父控件上加背景颜色
    3).尽量减少不必要的嵌套
    4).能用LinearLayout和FrameLayout，就不要用RelativeLayout，因为RelativeLayout控件相对比较复杂，测绘也想要耗时。
    5).使用include和merge增加复用，减少层级
    6).ViewStub按需加载，更加轻便
    7).复杂界面可选择ConstraintLayout，可有效减少层级

2、绘制优化：View的绘制频率保证60fps是最佳的，这就要求每帧绘制时间不超过16ms(16ms = 1000/60)，虽然程序很难保证16ms这个时间，但是尽量降低onDraw方法中的复杂度总是切实有效的。
    8).onDraw中不要创建新的局部对象
    9).onDraw方法中不要做耗时的任务

3、内存优化：(Profiler、Mat（内存泄漏）、TraceView（方法调用耗时、次数）)
新生代：复制算法
老年代：标记清除算法，会产生内存碎片，标记整理，需要复制，效率低
内存泄漏指的是那些程序不再使用的对象无法被GC识别，这样就导致这个对象一直留在内存当中，占用了本来就不多的内存空间。
因为有内存泄漏，所以内存被占用越来越多，那么GC会更容易被触发，GC会越来越频发，但是当GC的时候所有的线程都是暂停状态的，需要处理的对象数量越多耗时越长，所以这也会造成卡顿。
那么什么情况下会出现这样的对象呢？
基本可以分为以下四大类：
    10).集合类泄漏
    11).单例/静态变量造成的内存泄漏
    12).匿名内部类/非静态内部类
    13).资源未关闭造成的内存泄漏
        a).网络、文件等流忘记关闭
        b).手动注册广播时，退出时忘记 unregisterReceiver()
        c).Service 执行完后忘记 stopSelf()
        d).EventBus 等观察者模式的框架忘记手动解除注册

4、包体优化
    14).首先我们可以使用lint工具，同时我们可以开启资源压缩,自动删除无用的资源
    15).能自己用XML写Drawable，就自己写，能不用公司的UI切图
    16).重用资源
    17).使用WebP文件格式 可以使用图像的WebP文件格式
    18).代码混淆 使用proGuard 代码混淆器工具，它包括压缩、优化、混淆等功能
    19).插件化。 比如功能模块放在服务器上，按需下载，可以减少安装包大小


